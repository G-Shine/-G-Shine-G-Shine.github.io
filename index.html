<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"g-shine.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="欲穷大地三千界，须上高峰八百盘">
<meta property="og:type" content="website">
<meta property="og:title" content="鲲">
<meta property="og:url" content="https://g-shine.github.io/index.html">
<meta property="og:site_name" content="鲲">
<meta property="og:description" content="欲穷大地三千界，须上高峰八百盘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Shine Shine">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://g-shine.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>鲲</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">鲲</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Gao Shine’s Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shine Shine"
      src="/images/bike.jpg">
  <p class="site-author-name" itemprop="name">Shine Shine</p>
  <div class="site-description" itemprop="description">欲穷大地三千界，须上高峰八百盘</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-shine.github.io/2022/06/03/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/bike.jpg">
      <meta itemprop="name" content="Shine Shine">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲲">
      <meta itemprop="description" content="欲穷大地三千界，须上高峰八百盘">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 鲲">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 23:47:47" itemprop="dateCreated datePublished" datetime="2022-06-03T23:47:47+08:00">2022-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 18:03:49" itemprop="dateModified" datetime="2022-06-19T18:03:49+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><h2 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h2><p>（1）解决功能问性问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p>
<p>（2）解决扩展性问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p>
<p>  (3)   解决性能问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</p>
<h2 id="解决CPU及内存压力"><a href="#解决CPU及内存压力" class="headerlink" title="解决CPU及内存压力"></a>解决CPU及内存压力</h2><p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image002.gif" alt="截图.png"></p>
<h1 id><a href="#" class="headerlink" title></a></h1><p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image004.gif" alt="截图.png"></p>
<h2 id="解决IO压力"><a href="#解决IO压力" class="headerlink" title="解决IO压力"></a>解决IO压力</h2><p>频繁读取的放到缓存数据库里面；</p>
<p>数据库分表；</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image006.gif" alt="截图.png"></p>
<h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><p>NoSQL(NoSQL &#x3D; <strong>NotOnly SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 </p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p>
<p>l  不遵循SQL标准。</p>
<p>l  不支持ACID，事务特性。</p>
<p>l  远超于SQL的性能，key-value存取。</p>
<h1 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>l  对数据高并发的读写（秒杀）</p>
<p>l  海量数据的读写</p>
<p>l  对数据高可扩展性的</p>
<h3 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a>配合关系型数据库做高速缓存</h3><p> 高频次，热门访问的数据，降低数据库IO</p>
<p>分布式架构，做session共享</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image008.gif" alt="截图.png"></p>
<h3 id="多样的数据结构存储持久化数据"><a href="#多样的数据结构存储持久化数据" class="headerlink" title="多样的数据结构存储持久化数据"></a>多样的数据结构存储持久化数据</h3><p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image010.gif" alt="截图.png"></p>
<h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><p>l  需要事务支持</p>
<p>l  基于sql的结构化查询存储，处理复杂的关系,需要即时查询。</p>
<p><strong>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</strong></p>
<h1 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h1><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><table>
<thead>
<tr>
<th><img src="/2022/06/03/redis/clip_image012.gif" alt="截图.png"></th>
<th>几乎覆盖了Memcached的绝大部分功能数据都在内存中，支持持久化，主要用作备份恢复除了支持简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset等。一般是作为缓存数据库辅助持久化的数据库</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><table>
<thead>
<tr>
<th><img src="/2022/06/03/redis/clip_image014.gif" alt="截图.png"></th>
<th>高性能、开源、模式自由(schema  free)的<strong>文档型数据库</strong>数据都在内存中，   如果内存不足，把不常用的数据保存到硬盘虽然是key-value模式，但是对value（尤其是<strong>json</strong>）提供了丰富的查询功能支持二进制数据及大型对象可以根据数据的特点<strong>替代RDBMS</strong> ，成为独立的数据库。或者配合RDBMS，存储特定的数据。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="4-redis的概述安装"><a href="#4-redis的概述安装" class="headerlink" title="4.redis的概述安装"></a>4.redis的概述安装</h1><p>Ø Redis是一个开源的key-value存储系统。</p>
<p>Ø 和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</p>
<p>Ø 这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>Ø 在此基础上，Redis支持各种不同方式的排序。</p>
<p>Ø 与memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p>Ø 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>Ø 并且在此基础上实现了master-slave(主从)同步。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>版本6.2.1 、gcc(依赖C语言编译环境)</p>
<ol>
<li><pre><code>编译和安装
</code></pre>
</li>
</ol>
<p>#cd &#x2F;opt&#x2F;redis</p>
<p>#make  &amp;&amp; make instal  </p>
<p>默认安装后目录结构 &#x2F;usr&#x2F;local&#x2F;bin</p>
<p>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</p>
<p>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</p>
<p>redis-check-dump：修复有问题的dump.rdb文件</p>
<p>redis-sentinel：Redis集群使用</p>
<p>redis-server：Redis服务器启动命令</p>
<p>redis-cli：客户端，操作入口</p>
<p>3.前台启动   </p>
<p># cd &#x2F;usr&#x2F;local&#x2F;bin</p>
<p># redis-server</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image016.gif" alt="截图.png"></p>
<p>4.后台启动（推荐）</p>
<p>拷贝文件</p>
<p># cp &#x2F;opt&#x2F;redis&#x2F;conf&#x2F;redis.conf  &#x2F;etc&#x2F;</p>
<p>修改配置</p>
<p>后台启动设置daemonize no改成yes</p>
<p>#cd &#x2F;etc&#x2F; </p>
<p>#vim redis.conf </p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image018.gif" alt="截图.png"></p>
<p>启动</p>
<p>redis-server+指定配置文件(修改daemonize的配置文件)</p>
<p># cd &#x2F;usr&#x2F;local&#x2F;bin</p>
<p># redis-server  &#x2F;etc&#x2F;redis.conf</p>
<p>访问客户端&amp;验证</p>
<p>[root@Gshine bin]# redis-cli</p>
<p>127.0.0.1:6379&gt; ping</p>
<p>PONG</p>
<p>127.0.0.1:6379&gt;</p>
<p>关闭</p>
<p>单实例关闭 ，通过redis-cli shutdown &#x2F; 进程号均可关闭</p>
<p>​       多实例关闭，指定端口关闭：redis-cli -p 6379 shutdown</p>
<p>[root@Gshine bin]# redis-cli</p>
<p>127.0.0.1:6379&gt; shutdown</p>
<p>not connected&gt;</p>
<p>[root@Gshine bin]# ps -ef|grep redis</p>
<p>root       73831   70239  0 22:03 pts&#x2F;1    00:00:00 grep –color&#x3D;auto redis</p>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>默认端口：6379</p>
<p>默认有16个数据库，0-15，使用select 数字 切换数据库，统一密码管理，所有库同密码。</p>
<p>127.0.0.1:6379&gt; select 15</p>
<p>OK</p>
<p><strong>键操作（key）</strong></p>
<p>keys *查看当前库所有key    (匹配：keys *1)</p>
<p>exists key判断某个key是否存在</p>
<p>type key 查看你的key是什么类型</p>
<p>del key       删除指定的key数据</p>
<p>unlink key   根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p>expire key 10   10秒钟：为给定的key设置过期时间</p>
<p>ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p>select命令切换数据库</p>
<p>dbsize查看当前数据库的key的数量</p>
<p>flushdb清空当前库</p>
<p>flushall通杀全部库</p>
<p>dbsize查看当前数据库key的数量</p>
<p>127.0.0.1:6379&gt; dbsize</p>
<p>(integer) 0</p>
<p>flushdb 清空当前库</p>
<p>flushall 通杀全部库</p>
<p>底层实现原理：单线程+多路IO复用；</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image020.gif" alt="截图.png"></p>
<h1 id="5-常用数据类型"><a href="#5-常用数据类型" class="headerlink" title="5.常用数据类型"></a>5.常用数据类型</h1><h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><p>​      String是redis中最基本的数据类型，一个字符串value最多有512M.</p>
<p>​      String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>set  <key><value></value></key></p>
<p>添加键值对</p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  <key></key></p>
<p>查询对应键值</p>
<p>append  <key><value> 将给定的<value> 追加到原值的末尾</value></value></key></p>
<p>strlen  <key> 获得值的长度</key></p>
<p>setnx  <key><value>只有在 key 不存在时    设置 key的值</value></key></p>
<p>incr  <key>    将 key 中储存的数字值增1只能对数字值操作，如果为空，新增值为1</key></p>
<p>decr <key>    将 key 中储存的数字值减1只能对数字值操作，如果为空，新增值为-1</key></p>
<p>incrby &#x2F; decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。</key></p>
<p>mset  <key1><value1><key2><value2>  ….. </value2></key2></value1></key1></p>
<p>​     同时设置一个或多个key-value对  </p>
<p>mget  <key1><key2><key3> …..</key3></key2></key1></p>
<p>同时获取一个或多个value  </p>
<p>msetnx <key1><value1><key2><value2>  ….. </value2></key2></value1></key1></p>
<p>​      同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p>
<p><strong>原子性，有一个失败则都失败</strong></p>
<p>getrange  <key>&lt;起始位置&gt;&lt;结束位置&gt;</key></p>
<p>获得值的范围，类似java中的substring，<strong>前包，后包</strong></p>
<p>setrange  <key>&lt;起始位置&gt;<value></value></key></p>
<p>用<value>  覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</key></value></p>
<p><strong>setex  <key>&lt;过期时间&gt;<value></value></key></strong></p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p>getset <key><value></value></key></p>
<p>以新换旧，设置了新值同时获得旧值。</p>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image022.gif" alt="截图.png"></p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p>
<h2 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>单键对应多个值；</p>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>lpush&#x2F;rpush  <key><value1><value2><value3> ….  从左边&#x2F;右边插入一个或多个值。</value3></value2></value1></key></strong></p>
<p>lpop&#x2F;rpop  <key> 从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</key></p>
<p>rpoplpush <key1><key2>从<key1> 列表右边吐出一个值，插到<key2>列表左边。</key2></key1></key2></key1></p>
<p>lrange <key><start><stop></stop> 按照索引下标获得元素(从左到右)</start></key></p>
<p>lrange mylist 0 -1    0左边第一个，-1右边第一个，（0-1表示获取所有）</p>
<p>lindex <key><index> 按照索引下标获得元素(从左到右)</index></key></p>
<p>llen <key>   获得列表长度 </key></p>
<p>linsert <key>  before <value><newvalue> 在<value>的后面插入<newvalue>插入值</newvalue></value></newvalue></value></key></p>
<p>lrem <key><n><value> 从左边删除n个value(从左到右)</value></n></key></p>
<p>lset<key><index><value> 将列表key下标为index的值替换成value</value></index></key></p>
<h3 id="底层数据结构-1"><a href="#底层数据结构-1" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>List的数据结构为快速链表quickList。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image024.gif" alt="截图.png"></p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>单键多值，无排，自动去重。</p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>sadd <key><value1><value2> ….. </value2></value1></key></p>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</p>
<p>smembers <key>取出该集合的所有值。</key></p>
<p>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0</value></key></value></key></p>
<p>scard<key>返回该集合的元素个数。</key></p>
<p>srem <key><value1><value2> …. 删除集合中的某个元素。</value2></value1></key></p>
<p>spop <key><strong>随机从该集合中吐出一个值。</strong></key></p>
<p>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。</n></key></p>
<p>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合</destination></p>
<p>sinter <key1><key2>返回两个集合的交集元素。</key2></key1></p>
<p>sunion <key1><key2>返回两个集合的并集元素。</key2></key1></p>
<p>sdiff <key1><key2>返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</key2></key1></p>
<h3 id="底层数据结构-2"><a href="#底层数据结构-2" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>Set数据结构是dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>第三种最为常用。</p>
<p>Redis hash 是一个键值对集合。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image026.gif" alt="截图.png"></p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储</p>
<p>主要有以下2种存储方式：</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image028.gif" alt="截图.png"></p>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><p>hset <key><field><value>给<key>集合中的  <field>键赋值<value></value></field></key></value></field></key></p>
<p>hget <key1><field>从<key1>集合<field>取出 value </field></key1></field></key1></p>
<p>hmset <key1><field1><value1><field2><value2>…批量设置hash的值</value2></field2></value1></field1></key1></p>
<p>hexists<key1><field>查看哈希表 key 中，给定域 field 是否存在。 </field></key1></p>
<p>hkeys<key>列出该hash集合的所有field</key></p>
<p>hvals<key>列出该hash集合的所有value</key></p>
<p>hincrby<key><field><increment>为哈希表 key 中的域 field 的值加上增量 1   -1</increment></field></key></p>
<p>hsetnx<key><field><value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域field 不存在 .</value></field></key></p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><p>zadd <key><score1><value1><score2><value2>…</value2></score2></value1></score1></key></p>
<p>将一个或多个 member 元素及其 score 值加入到有序集 key当中。</p>
<p><strong>zrange <key><start><stop></stop> [WITHSCORES]</start></key></strong>   </p>
<p>返回有序集 key 中，下标在<start><stop></stop>之间的元素，带WITHSCORES，可以让分数一起和值返回到结果集。</start></p>
<p>zrangebyscore key minmax [withscores][limit offset count]</p>
<p>返回有序集 key 中，所有 score 值介于 min和 max 之间(包括等于 min或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p>
<p>zrevrangebyscore key maxmin [withscores][limit offset count]  </p>
<p>同上，改为从大到小排列。 </p>
<p>zincrby <key><increment><value>       为元素的score加上增量</value></increment></key></p>
<p>zrem  <key><value></value></key></p>
<p>删除该集合下，指定值的元素</p>
<p>zcount <key><min><max></max></min></key></p>
<p>统计该集合，分数区间内的元素个数 </p>
<p>zrank <key><value></value></key></p>
<p>返回该值在集合中的排名，从0开始。</p>
<h3 id="底层数据结构-3"><a href="#底层数据结构-3" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p>zset底层使用了两个数据结构</p>
<p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p>
<h1 id="6-reids的配置文件"><a href="#6-reids的配置文件" class="headerlink" title="6.reids的配置文件"></a>6.reids的配置文件</h1><p>redis.conf</p>
<h2 id="包含includes"><a href="#包含includes" class="headerlink" title="包含includes"></a>包含includes</h2><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h2 id="网络配置bind"><a href="#网络配置bind" class="headerlink" title="网络配置bind"></a>网络配置bind</h2><p>默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求</p>
<p>不写的情况下，无限制接受任何ip地址的访问</p>
<p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</p>
<h2 id="端口号Port"><a href="#端口号Port" class="headerlink" title="端口号Port"></a>端口号Port</h2><p>6379</p>
<h2 id="连接队列tcp-backlog"><a href="#连接队列tcp-backlog" class="headerlink" title="连接队列tcp-backlog"></a>连接队列tcp-backlog</h2><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值（128），所以需要确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果</p>
<h2 id="超时timeout"><a href="#超时timeout" class="headerlink" title="超时timeout"></a>超时timeout</h2><p>对访问客户端的一种心跳检测，每个n秒检测一次。</p>
<p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </p>
<h2 id="守护进程daemonize"><a href="#守护进程daemonize" class="headerlink" title="守护进程daemonize"></a>守护进程daemonize</h2><p>是否为后台进程，设置为yes</p>
<p>守护进程，后台启动</p>
<h2 id="进程号pidfile"><a href="#进程号pidfile" class="headerlink" title="进程号pidfile"></a>进程号pidfile</h2><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p>
<h2 id="日志级别loglevel"><a href="#日志级别loglevel" class="headerlink" title="日志级别loglevel"></a>日志级别loglevel</h2><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为<strong>notice</strong></p>
<p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p>
<h2 id="日志名称logfile"><a href="#日志名称logfile" class="headerlink" title="日志名称logfile"></a>日志名称logfile</h2><p>日志文件名称</p>
<h2 id="数据库databases-16"><a href="#数据库databases-16" class="headerlink" title="数据库databases 16"></a>数据库databases 16</h2><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</dbid></p>
<h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>访问密码的查看、设置和取消</p>
<p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p>
<p>永久设置，需要再配置文件中进行设置。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image030.gif" alt="截图.png"></p>
<h2 id="连接限制maxclients"><a href="#连接限制maxclients" class="headerlink" title="连接限制maxclients"></a>连接限制maxclients</h2><p>设置redis同时可以与多少个客户端进行连接。</p>
<p>默认情况下为10000个客户端。</p>
<p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<h2 id="最大内存maxmemory"><a href="#最大内存maxmemory" class="headerlink" title="最大内存maxmemory"></a>最大内存maxmemory</h2><p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</p>
<p>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p>
<p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<h2 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h2><p>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</p>
<p>allkeys-lru：在所有集合key中，使用LRU算法移除key</p>
<p>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</p>
<p>allkeys-random：在所有集合key中，移除随机的key</p>
<p>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</p>
<p>noeviction：不进行移除。针对写操作，只是返回错误信息</p>
<h2 id="maxmemory-sample"><a href="#maxmemory-sample" class="headerlink" title="maxmemory-sample"></a>maxmemory-sample</h2><p>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</p>
<p>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小</p>
<h1 id="7-发布订阅"><a href="#7-发布订阅" class="headerlink" title="7.发布订阅"></a>7.发布订阅</h1><h2 id="什么是发布与订阅"><a href="#什么是发布与订阅" class="headerlink" title="什么是发布与订阅"></a>什么是发布与订阅</h2><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image032.gif" alt="截图.png"></p>
<h2 id="发布与订阅实现"><a href="#发布与订阅实现" class="headerlink" title="发布与订阅实现"></a>发布与订阅实现</h2><p>订阅（1客户端）</p>
<p>SUBSCRIBE channel1</p>
<p>发布（2客户端）</p>
<p>publish channel1 hello</p>
<p>​    接收（1客户端）</p>
<p>hello</p>
<h1 id="8-Redis新数据类型"><a href="#8-Redis新数据类型" class="headerlink" title="8.Redis新数据类型"></a>8.Redis新数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<ol>
<li><pre><code>[Bitmaps](true)本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。
</code></pre>
</li>
<li><pre><code>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。
</code></pre>
</li>
</ol>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image034.gif" alt="截图.png"></p>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>setbit</strong></p>
<p>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）</value></offset></key></p>
<p>*offset:偏移量从0开始</p>
<p><strong>getbit</strong></p>
<p>getbit<key><offset>获取Bitmaps中某个偏移量的值</offset></key></p>
<p><strong>bitcount</strong></p>
<p>统计<strong>字符串</strong>被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p>
<p>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</key></p>
<h3 id="Bitmaps与map对比"><a href="#Bitmaps与map对比" class="headerlink" title="Bitmaps与map对比"></a>Bitmaps与map对比</h3><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image036.gif" alt="截图.png"></p>
<p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间，尤其是随着时间推移节省的内存还是非常可观的</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image038.gif" alt="截图.png"></p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p>
<p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><p>pfadd</p>
<p>pfadd <key>&lt; element&gt; [element …]   添加指定元素到 HyperLogLog 中</key></p>
<p>pfcount</p>
<p>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</key></p>
<p>pfmerge</p>
<p>pfmerge<destkey><sourcekey> [sourcekey…]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</sourcekey></destkey></p>
<h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><p>Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h3 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h3><p>geoadd</p>
<p>geoadd<key>&lt; longitude&gt;<latitude><member>[longitude latitude member…]   添加地理位置（经度，纬度，名称）</member></latitude></key></p>
<p>geopos</p>
<p>geopos <key><member> [member…] 获得指定地区的坐标值</member></key></p>
<p>geodist</p>
<p>geodist<key><member1><member2>  [m|km|ft|mi ] 获取两个位置之间的直线距离</member2></member1></key></p>
<p>georadius</p>
<p>georadius<key>&lt; longitude&gt;<latitude>radius  m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</latitude></key></p>
<h1 id="9-Redis事务"><a href="#9-Redis事务" class="headerlink" title="9.Redis事务"></a>9.Redis事务</h1><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p>
<h2 id="Multi-Exec-Discard"><a href="#Multi-Exec-Discard" class="headerlink" title="Multi Exec Discard"></a>Multi Exec Discard</h2><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过discard来放弃组队。  </p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image040.gif" alt="截图.png"></p>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image042.gif" alt="截图.png"></p>
<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image044.gif" alt="截图.png"></p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image046.gif" alt="截图.png"></p>
<p>乐观锁</p>
<p><strong>乐观锁(Optimistic Lock),</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<strong>在更新的时候会判断一下在此期间别人有没有去更新这个数据</strong>，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image048.gif" alt="截图.png"></p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>   在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务<strong>执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong></p>
<p>取消 WATCH 命令对所有 key 的监视。</p>
<h2 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a>unwatch</h2><p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p>
<h2 id="Redis事物的三特性"><a href="#Redis事物的三特性" class="headerlink" title="Redis事物的三特性"></a>Redis事物的三特性</h2><p>l  单独的隔离操作 </p>
<p>n  事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
<p>l  没有隔离级别的概念 </p>
<p>n  队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
<p>l  不保证原子性 </p>
<p>n  事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 </p>
<h1 id="10-持久化"><a href="#10-持久化" class="headerlink" title="10.持久化"></a>10.持久化</h1><p>Redis提供了RDB和AOF二种持久化策略</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里</p>
<p>如何执行</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image050.gif" alt="截图.png"></p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<h1 id="11-Redis主从复制"><a href="#11-Redis主从复制" class="headerlink" title="11.Redis主从复制"></a>11.Redis主从复制</h1><h2 id="搭建主从复制"><a href="#搭建主从复制" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h2><p>一台机器实现</p>
<p>（1）新建一个目录，存放redis.conf文件（&#x2F;usr&#x2F;local&#x2F;myredis）</p>
<p>（2）新建redis6379.conf、redis6380.conf、redis6381.conf三个文件（三个文件均为空内容）</p>
<p>（3）编辑（2）中三个文件，新增对应的内容：</p>
<p>include:多实例的情况可以把公用的配置文件提取出来</p>
<p>include &#x2F;myredis&#x2F;redis.conf</p>
<p>pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</p>
<p>port 6379</p>
<p>dbfilename dump6379.rdb</p>
<p>include &#x2F;myredis&#x2F;redis.conf</p>
<p>pidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pid</p>
<p>port 6380</p>
<p>dbfilename dump6379.rdb</p>
<p>include &#x2F;myredis&#x2F;redis.conf</p>
<p>pidfile &#x2F;var&#x2F;run&#x2F;redis_6381.pid</p>
<p>port 6381</p>
<p>dbfilename dump6381.rdb</p>
<p>（4）启动&amp;查看三台服务器的进程</p>
<p>[root@Gshine myredis]# redis-server redis6379.conf</p>
<p>[root@Gshine myredis]# redis-server redis6380.conf</p>
<p>[root@Gshine myredis]# redis-server redis6381.conf</p>
<p>[root@Gshine myredis]# ps -ef|grep redis</p>
<p>root       74620       1  0 Jun15 ?        00:17:08 redis-server 127.0.0.1:6379</p>
<p>root     1046904       1  0 10:58 ?        00:00:00 redis-server 127.0.0.1:6380</p>
<p>root     1046920       1  0 10:58 ?        00:00:00 redis-server 127.0.0.1:6381</p>
<p>root     1046956 1044464  0 10:58 pts&#x2F;1    00:00:00 grep –color&#x3D;auto redis</p>
<p>（5）将从加入主，主不用操作</p>
<p>slaveof  <ip> <port> 因为是一台服务器配置一主二从，ip127.0.0.1即可，如果是多台更换ip即可</port></ip></p>
<p>#在6381执行</p>
<p>[root@Gshine myredis]# redis-cli -p 6381</p>
<p>127.0.0.1:6381&gt; slaveof 127.0.0.1 6379</p>
<p>OK</p>
<p>#在6380执行</p>
<p>[root@Gshine myredis]# redis-cli -p 6380</p>
<p>127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</p>
<p>OK</p>
<p>（6）验证</p>
<p>info replication</p>
<p>l  读写分离，性能扩展</p>
<p>l  容灾快速恢复</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image052.gif" alt="截图.png"></p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>（1）从连接主后，从向主发送sync（同步）命令。</p>
<p>（2）Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步；</p>
<p>（3）增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</p>
<p>（4）全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p>注意：从服务器只要是重新连接Master，一次完全同步（全量复制）将被执行</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image054.gif" alt="截图.png"></p>
<h2 id="常用三招"><a href="#常用三招" class="headerlink" title="常用三招"></a>常用三招</h2><h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><p>（1）从挂掉后情况</p>
<p>主状态显示，只剩余一个从（因为另外要一个从挂掉）；</p>
<p>从重启后，状态显示自身是主，数据为空；</p>
<p>重新连接主后，根据主从复制原理，状态显示为主，数据恢复。</p>
<p>（2）主挂掉后</p>
<p>从状态显示，自身还是从；</p>
<p>主重启后，恢复；</p>
<h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><p>从设置从，主只需要和一台从或少量从配置，从和其它从在做配置。</p>
<p>缺点：从挂掉后，后面也断了；</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image056.gif" alt="截图.png"></p>
<h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><p>主挂掉后，从升为主，命令：slaveof  no one  将从机变为主机</p>
<p>缺点：需手工</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。、</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image058.gif" alt="截图.png"></p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>（1）先调整为一主二从模式；在&#x2F;usr&#x2F;local&#x2F;myredis&#x2F;新建sentinel.conf文件（内容为空），名字一定不能错。</p>
<p>（2）增加内容</p>
<p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p>
<p>entinel monitor mymaster 127.0.0.1 6379 1</p>
<p>（3）启动哨兵</p>
<p>哨兵端口号是26379</p>
<p>redis-sentinel .&#x2F;sentinel.conf </p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image060.gif" alt="截图.png"></p>
<p>（3）选举</p>
<p>当主挂掉后，从选举新的主；在启动旧的主，旧主就会变为从；</p>
<p>影响选举的因素？</p>
<p>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高</p>
<p>偏移量是指获得原主机数据最全的（可以理解为key最多的）</p>
<p>每个redis实例启动后都会随机生成一个40位的runid</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image062.gif" alt="截图.png"></p>
<h1 id="12-Redis集群"><a href="#12-Redis集群" class="headerlink" title="12.Redis集群"></a>12.Redis集群</h1><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>容量不够，redis如何进行扩容？</p>
<p>并发写操作， redis如何分摊？</p>
<p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p>
<p>通过任何一个入口即可操作集群。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image064.gif" alt="截图.png"></p>
<h2 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h2><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h2 id="搭建一个集群"><a href="#搭建一个集群" class="headerlink" title="搭建一个集群"></a>搭建一个集群</h2><p>（1）配置文件中增加以下内容（新建6个redis6379-7381.conf文件）</p>
<p>cluster-enabled yes    打开集群模式</p>
<p>cluster-config-file nodes-6379.conf  设定节点配置文件名</p>
<p>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p>
<p>cluster-enabled yes</p>
<p>cluster-config-file nodes-6379.conf</p>
<p>cluster-node-timeout 15000</p>
<p>（2）启动6台redis</p>
<p>实例启动后，nodes-xxxx.conf文件都生成正常。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image066.gif" alt="截图.png"></p>
<p>（3）将6台机器合为一个集群</p>
<p>在 cd &#x2F;opt&#x2F;redis-6.2.1&#x2F;src  目录下执行以下命令：</p>
<p>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p>
<p>分配原则：主机分开，主从分开</p>
<p>redis-cli –cluster create –cluster-replicas 1 192.168.11.101:6379</p>
<p> 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389</p>
<p>192.168.11.101:6390 192.168.11.101:6391</p>
<p> （4）登陆主机</p>
<p>以集群方式登陆。</p>
<p>redis-cli -c -p 6379</p>
<p>   (5)    查看集群状态</p>
<p>cluster nodes</p>
<h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h2><p>集群创建成功后有以下图显示</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image068.gif" alt="截图.png"></p>
<p>一个 Redis 集群包含 16384 个插槽（hashslot）， 数据库中的每个键都属于这 16384个插槽的其中一个， </p>
<p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<p>节点 A 负责处理 0 号至 5460 号插槽。</p>
<p>节点 B 负责处理 5461 号至 10922 号插槽。</p>
<p>节点 C 负责处理 10923 号至 16383 号插槽。</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><h3 id="主挂掉"><a href="#主挂掉" class="headerlink" title="主挂掉"></a>主挂掉</h3><p>从升主，重新启动旧主，变从；</p>
<h3 id="主从都挂掉"><a href="#主从都挂掉" class="headerlink" title="主从都挂掉"></a>主从都挂掉</h3><p>能否继续提供服务，要根据redis.conf中的参数 cluster-require-full-coverage</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage为yes ，那么 ，整个集群都挂掉</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage为no，那么，该插槽数据全都不能使用，也无法存储。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image070.gif" alt="截图.png"></p>
<h1 id="13应用问题"><a href="#13应用问题" class="headerlink" title="13应用问题"></a>13应用问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>利用缓存中查不到值，请求压到数据库，从而可能压垮数据源。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image072.gif" alt="截图.png"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><pre><code>   **对空值缓存：**如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟
</code></pre>
</li>
<li><pre><code>   **设置可访问的名单（白名单）：**
</code></pre>
</li>
</ol>
<p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p>
<ol start="3">
<li><strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</li>
</ol>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p>
<p>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p><strong>4.进行实时监控：</strong>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>高频的key过期了，压力到数据库</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image074.gif" alt="截图.png"></p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image076.gif" alt="截图.png"></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>（1）预先设置热门数据：</strong>在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</p>
<p><strong>（2）实时调整：</strong>现场监控哪些数据热门，实时调整key的过期时长</p>
<p><strong>（3）使用锁：</strong></p>
<h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image078.gif" alt="截图.png"></p>
<p>解决方案</p>
<ol>
<li><pre><code>**构建多级缓存架构：**nginx缓存 + redis缓存 +其他缓存（ehcache等）
</code></pre>
</li>
<li><pre><code>**使用锁或队列：**
</code></pre>
</li>
</ol>
<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p>
<p><strong>3.设置过期标志更新缓存：</strong></p>
<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p>
<p><strong>4.将缓存失效时间分散开：</strong></p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h1 id="14-分布式锁"><a href="#14-分布式锁" class="headerlink" title="14.分布式锁"></a>14.分布式锁</h1><h2 id="使用redis实现分布式锁"><a href="#使用redis实现分布式锁" class="headerlink" title="使用redis实现分布式锁"></a>使用redis实现分布式锁</h2><p>set sku:1:info “OK” NX PX 10000</p>
<p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p>
<p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p>
<p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p>
<p>XX ：只在键已经存在时，才对键进行设置操作。</p>
<p><img src="/2022/06/03/redis/MyBlog/source/_posts/redis/clip_image080.gif" alt="截图.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shine Shine</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
